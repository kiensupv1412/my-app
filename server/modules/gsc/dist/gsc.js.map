{"version":3,"sources":["../src/auth.ts","../src/utils.ts","../src/types.ts","../src/gsc.ts","../src/sitemap.ts","../src/index.ts","../index.ts","../package.json","../cli.ts"],"sourcesContent":["import { google } from \"googleapis\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport os from \"os\";\n\n/**\n * Retrieves an access token for Google APIs using service account credentials.\n * @param client_email - The client email of the service account.\n * @param private_key - The private key of the service account.\n * @param customPath - (Optional) Custom path to the service account JSON file.\n * @returns The access token.\n */\nexport async function getAccessToken(client_email?: string, private_key?: string, customPath?: string) {\n  if (!client_email && !private_key) {\n    const filePath = \"service_account.json\";\n    const filePathFromHome = path.join(os.homedir(), \".gis\", \"service_account.json\");\n    const isFile = fs.existsSync(filePath);\n    const isFileFromHome = fs.existsSync(filePathFromHome);\n    const isCustomFile = !!customPath && fs.existsSync(customPath);\n\n    if (!isFile && !isFileFromHome && !isCustomFile) {\n      console.error(`❌ ${filePath} not found, please follow the instructions in README.md`);\n      console.error(\"\");\n      process.exit(1);\n    }\n\n    const key = JSON.parse(\n      fs.readFileSync(!!customPath && isCustomFile ? customPath : isFile ? filePath : filePathFromHome, \"utf8\")\n    );\n    client_email = key.client_email;\n    private_key = key.private_key;\n  } else {\n    if (!client_email) {\n      console.error(\"❌ Missing client_email in service account credentials.\");\n      console.error(\"\");\n      process.exit(1);\n    }\n\n    if (!private_key) {\n      console.error(\"❌ Missing private_key in service account credentials.\");\n      console.error(\"\");\n      process.exit(1);\n    }\n  }\n\n  const jwtClient = new google.auth.JWT(\n    client_email, undefined, private_key,\n    [\"https://www.googleapis.com/auth/webmasters.readonly\", \"https://www.googleapis.com/auth/indexing\"],\n    undefined\n  );\n\n  const tokens = await jwtClient.authorize();\n  return tokens.access_token;\n}","/**\n * Creates an array of chunks from the given array with a specified size.\n * @param arr The array to be chunked.\n * @param size The size of each chunk.\n * @returns An array of chunks.\n */\nconst createChunks = (arr: any[], size: number) =>\n  Array.from({ length: Math.ceil(arr.length / size) }, (_, i) => arr.slice(i * size, i * size + size));\n\n/**\n * Executes tasks on items in batches and invokes a callback upon completion of each batch.\n * @param task The task function to be executed on each item.\n * @param items The array of items on which the task is to be executed.\n * @param batchSize The size of each batch.\n * @param onBatchComplete The callback function invoked upon completion of each batch.\n */\nexport async function batch(\n  task: (url: string) => void,\n  items: string[],\n  batchSize: number,\n  onBatchComplete: (batchIndex: number, batchCount: number) => void\n) {\n  const chunks = createChunks(items, batchSize);\n  for (let i = 0; i < chunks.length; i++) {\n    await Promise.all(chunks[i].map(task));\n    onBatchComplete(i, chunks.length);\n  }\n}\n\n/**\n * Fetches a resource from a URL with retry logic.\n * @param url The URL of the resource to fetch.\n * @param options The options for the fetch request.\n * @param retries The number of retry attempts (default is 5).\n * @returns A Promise resolving to the fetched response.\n * @throws Error when retries are exhausted or server error occurs.\n */\nexport async function fetchRetry(url: string, options: RequestInit, retries: number = 5) {\n  try {\n    const response = await fetch(url, options);\n    if (response.status >= 500) {\n      const body = await response.text();\n      throw new Error(`Server error code ${response.status}\\n${body}`);\n    }\n    return response;\n  } catch (err) {\n    if (retries <= 0) {\n      throw err;\n    }\n    return fetchRetry(url, options, retries - 1);\n  }\n}","/**\n * Enum representing indexing status of a URL\n */\nexport enum Status {\n  SubmittedAndIndexed = \"Submitted and indexed\",\n  DuplicateWithoutUserSelectedCanonical = \"Duplicate without user-selected canonical\",\n  CrawledCurrentlyNotIndexed = \"Crawled - currently not indexed\",\n  DiscoveredCurrentlyNotIndexed = \"Discovered - currently not indexed\",\n  PageWithRedirect = \"Page with redirect\",\n  URLIsUnknownToGoogle = \"URL is unknown to Google\",\n  RateLimited = \"RateLimited\",\n  Forbidden = \"Forbidden\",\n  Error = \"Error\",\n}","import { webmasters_v3 } from \"googleapis\";\nimport { fetchRetry } from \"./utils\";\nimport { Status } from \"./types\";\n\n/**\n * Converts a given input string to a valid Google Search Console site URL format.\n * @param input - The input string to be converted.\n * @returns The converted site URL (domain.com or https://domain.com/)\n */\nexport function convertToSiteUrl(input: string) {\n  if (input.startsWith(\"http://\") || input.startsWith(\"https://\")) {\n    return input.endsWith(\"/\") ? input : `${input}/`;\n  }\n  return `sc-domain:${input}`;\n}\n\n/**\n * Converts a given file path to a formatted version suitable for use as a file name.\n * @param path - The url to be converted as a file name\n * @returns The converted file path\n */\nexport function convertToFilePath(path: string) {\n  return path.replace(\"http://\", \"http_\").replace(\"https://\", \"https_\").replaceAll(\"/\", \"_\");\n}\n\n/**\n * Converts an HTTP URL to a sc-domain URL format.\n * @param httpUrl The HTTP URL to be converted.\n * @returns The sc-domain formatted URL.\n */\nexport function convertToSCDomain(httpUrl: string) {\n  return `sc-domain:${httpUrl.replace(\"http://\", \"\").replace(\"https://\", \"\").replace(\"/\", \"\")}`;\n}\n\n/**\n * Converts a domain to an HTTP URL.\n * @param domain The domain to be converted.\n * @returns The HTTP URL.\n */\nexport function convertToHTTP(domain: string) {\n  return `http://${domain}/`;\n}\n\n/**\n * Converts a domain to an HTTPS URL.\n * @param domain The domain to be converted.\n * @returns The HTTPS URL.\n */\nexport function convertToHTTPS(domain: string) {\n  return `https://${domain}/`;\n}\n\n/**\n * Retrieves a list of sites associated with the specified service account from the Google Webmasters API.\n * @param accessToken - The access token for authentication.\n * @returns An array containing the site URLs associated with the service account.\n */\nexport async function getSites(accessToken: string) {\n  const sitesResponse = await fetchRetry(\"https://www.googleapis.com/webmasters/v3/sites\", {\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${accessToken}`,\n    },\n  });\n\n  if (sitesResponse.status === 403) {\n    console.error(\"🔐 This service account doesn't have access to any sites.\");\n    return [];\n  }\n\n  const sitesBody: webmasters_v3.Schema$SitesListResponse = await sitesResponse.json();\n\n  if (!sitesBody.siteEntry) {\n    console.error(\"❌ No sites found, add them to Google Search Console and try again.\");\n    return [];\n  }\n\n  return sitesBody.siteEntry.map((x) => x.siteUrl);\n}\n\n/**\n * Checks if the site URL is valid and accessible by the service account.\n * @param accessToken - The access token for authentication.\n * @param siteUrl - The URL of the site to check.\n * @returns The corrected URL if found, otherwise the original site URL.\n */\nexport async function checkSiteUrl(accessToken: string, siteUrl: string) {\n  const sites = await getSites(accessToken);\n  let formattedUrls: string[] = [];\n\n  // Convert the site URL into all possible formats\n  if (siteUrl.startsWith(\"https://\")) {\n    formattedUrls.push(siteUrl);\n    formattedUrls.push(convertToHTTP(siteUrl.replace(\"https://\", \"\")));\n    formattedUrls.push(convertToSCDomain(siteUrl));\n  } else if (siteUrl.startsWith(\"http://\")) {\n    formattedUrls.push(siteUrl);\n    formattedUrls.push(convertToHTTPS(siteUrl.replace(\"http://\", \"\")));\n    formattedUrls.push(convertToSCDomain(siteUrl));\n  } else if (siteUrl.startsWith(\"sc-domain:\")) {\n    formattedUrls.push(siteUrl);\n    formattedUrls.push(convertToHTTP(siteUrl.replace(\"sc-domain:\", \"\")));\n    formattedUrls.push(convertToHTTPS(siteUrl.replace(\"sc-domain:\", \"\")));\n  } else {\n    console.error(\"❌ Unknown site URL format.\");\n    console.error(\"\");\n    process.exit(1);\n  }\n\n  // Check if any of the formatted URLs are accessible\n  for (const formattedUrl of formattedUrls) {\n    if (sites.includes(formattedUrl)) {\n      return formattedUrl;\n    }\n  }\n\n  // If none of the formatted URLs are accessible\n  console.error(\"❌ This service account doesn't have access to this site.\");\n  console.error(\"\");\n  process.exit(1);\n}\n\n/**\n * Checks if the given URLs are valid.\n * @param siteUrl - The URL of the site.\n * @param urls - The URLs to check.\n * @returns An array containing the corrected URLs if found, otherwise the original URLs\n */\nexport function checkCustomUrls(siteUrl: string, urls: string[]) {\n  const protocol = siteUrl.startsWith(\"http://\") ? \"http://\" : \"https://\";\n  const domain = siteUrl.replace(\"https://\", \"\").replace(\"http://\", \"\").replace(\"sc-domain:\", \"\");\n  const formattedUrls: string[] = urls.map((url) => {\n    url = url.trim();\n    if (url.startsWith(\"/\")) {\n      // the url is a relative path (e.g. /about)\n      return `${protocol}${domain}${url}`;\n    } else if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n      // the url is already a full url (e.g. https://domain.com/about)\n      return url;\n    } else if (url.startsWith(domain)) {\n      // the url is a full url without the protocol (e.g. domain.com/about)\n      return `${protocol}${url}`;\n    } else {\n      // the url is a relative path without the leading slash (e.g. about)\n      return `${protocol}${domain}/${url}`;\n    }\n  });\n\n  return formattedUrls;\n}\n\n/**\n * Retrieves the indexing status of a page.\n * @param accessToken - The access token for authentication.\n * @param siteUrl - The URL of the site.\n * @param inspectionUrl - The URL of the page to inspect.\n * @returns A promise resolving to the status of indexing.\n */\nexport async function getPageIndexingStatus(\n  accessToken: string,\n  siteUrl: string,\n  inspectionUrl: string\n): Promise<Status> {\n  try {\n    const response = await fetchRetry(`https://searchconsole.googleapis.com/v1/urlInspection/index:inspect`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify({\n        inspectionUrl,\n        siteUrl,\n      }),\n    });\n\n    if (response.status === 403) {\n      console.error(`🔐 This service account doesn't have access to this site.`);\n      console.error(await response.text());\n\n      return Status.Forbidden;\n    }\n\n    if (response.status >= 300) {\n      if (response.status === 429) {\n        return Status.RateLimited;\n      } else {\n        console.error(`❌ Failed to get indexing status.`);\n        console.error(`Response was: ${response.status}`);\n        console.error(await response.text());\n\n        return Status.Error;\n      }\n    }\n\n    const body = await response.json();\n    return body.inspectionResult.indexStatusResult.coverageState;\n  } catch (error) {\n    console.error(`❌ Failed to get indexing status.`);\n    console.error(`Error was: ${error}`);\n    throw error;\n  }\n}\n\n/**\n * Retrieves an emoji representation corresponding to the given status.\n * @param status - The status for which to retrieve the emoji.\n * @returns The emoji representing the status.\n */\nexport function getEmojiForStatus(status: Status) {\n  switch (status) {\n    case Status.SubmittedAndIndexed:\n      return \"✅\";\n    case Status.DuplicateWithoutUserSelectedCanonical:\n      return \"😵\";\n    case Status.CrawledCurrentlyNotIndexed:\n    case Status.DiscoveredCurrentlyNotIndexed:\n      return \"👀\";\n    case Status.PageWithRedirect:\n      return \"🔀\";\n    case Status.URLIsUnknownToGoogle:\n      return \"❓\";\n    case Status.RateLimited:\n      return \"🚦\";\n    default:\n      return \"❌\";\n  }\n}\n\n/**\n * Retrieves metadata for publishing from the given URL.\n * @param accessToken - The access token for authentication.\n * @param url - The URL for which to retrieve metadata.\n * @param options - The options for the request.\n * @returns The status of the request.\n */\nexport async function getPublishMetadata(accessToken: string, url: string, options?: { retriesOnRateLimit: number }) {\n  const response = await fetchRetry(\n    `https://indexing.googleapis.com/v3/urlNotifications/metadata?url=${encodeURIComponent(url)}`,\n    {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${accessToken}`,\n      },\n    }\n  );\n\n  if (response.status === 403) {\n    console.error(`🔐 This service account doesn't have access to this site.`);\n    console.error(`Response was: ${response.status}`);\n    console.error(await response.text());\n  }\n\n  if (response.status === 429) {\n    if (options?.retriesOnRateLimit && options?.retriesOnRateLimit > 0) {\n      const RPM_WATING_TIME = (QUOTA.rpm.retries - options.retriesOnRateLimit + 1) * QUOTA.rpm.waitingTime; // increase waiting time for each retry\n      console.log(\n        `🚦 Rate limit exceeded for read requests. Retries left: ${options.retriesOnRateLimit}. Waiting for ${RPM_WATING_TIME / 1000\n        }sec.`\n      );\n      await new Promise((resolve) => setTimeout(resolve, RPM_WATING_TIME));\n      await getPublishMetadata(accessToken, url, { retriesOnRateLimit: options.retriesOnRateLimit - 1 });\n    } else {\n      console.error(\"🚦 Rate limit exceeded, try again later.\");\n      console.error(\"\");\n      console.error(\"   Quota: https://developers.google.com/search/apis/indexing-api/v3/quota-pricing#quota\");\n      console.error(\"   Usage: https://console.cloud.google.com/apis/enabled\");\n      console.error(\"\");\n      process.exit(1);\n    }\n  }\n\n  if (response.status >= 500) {\n    console.error(`❌ Failed to get publish metadata.`);\n    console.error(`Response was: ${response.status}`);\n    console.error(await response.text());\n  }\n\n  return response.status;\n}\n\n/**\n * Requests indexing for the given URL.\n * @param accessToken - The access token for authentication.\n * @param url - The URL to be indexed.\n */\nexport async function requestIndexing(accessToken: string, url: string) {\n  const response = await fetchRetry(\"https://indexing.googleapis.com/v3/urlNotifications:publish\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${accessToken}`,\n    },\n    body: JSON.stringify({\n      url: url,\n      type: \"URL_UPDATED\",\n    }),\n  });\n\n  if (response.status === 403) {\n    console.error(`🔐 This service account doesn't have access to this site.`);\n    console.error(`Response was: ${response.status}`);\n  }\n\n  if (response.status >= 300) {\n    if (response.status === 429) {\n      console.error(\"🚦 Rate limit exceeded, try again later.\");\n      console.error(\"\");\n      console.error(\"   Quota: https://developers.google.com/search/apis/indexing-api/v3/quota-pricing#quota\");\n      console.error(\"   Usage: https://console.cloud.google.com/apis/enabled\");\n      console.error(\"\");\n      process.exit(1);\n    } else {\n      console.error(`❌ Failed to request indexing.`);\n      console.error(`Response was: ${response.status}`);\n      console.error(await response.text());\n    }\n  }\n}","import Sitemapper from \"sitemapper\";\nimport { fetchRetry } from \"./utils\";\nimport { webmasters_v3 } from \"googleapis\";\n\n/**\n * Retrieves a list of sitemaps associated with the specified site URL from the Google Webmasters API.\n * @param accessToken The access token for authentication.\n * @param siteUrl The URL of the site for which to retrieve the list of sitemaps.\n * @returns An array containing the paths of the sitemaps associated with the site URL.\n */\nasync function getSitemapsList(accessToken: string, siteUrl: string) {\n  const url = `https://www.googleapis.com/webmasters/v3/sites/${encodeURIComponent(siteUrl)}/sitemaps`;\n\n  const response = await fetchRetry(url, {\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${accessToken}`,\n    },\n  });\n\n  if (response.status === 403) {\n    console.error(`🔐 This service account doesn't have access to this site.`);\n    return [];\n  }\n\n  if (response.status >= 300) {\n    console.error(`❌ Failed to get list of sitemaps.`);\n    console.error(`Response was: ${response.status}`);\n    console.error(await response.text());\n    return [];\n  }\n\n  const body: webmasters_v3.Schema$SitemapsListResponse = await response.json();\n\n  if (!body.sitemap) {\n    console.error(\"❌ No sitemaps found, add them to Google Search Console and try again.\");\n    return [];\n  }\n\n  return body.sitemap.filter((x) => x.path !== undefined && x.path !== null).map((x) => x.path as string);\n}\n\n/**\n * Retrieves a list of pages from all sitemaps associated with the specified site URL.\n * @param accessToken The access token for authentication.\n * @param siteUrl The URL of the site for which to retrieve the sitemap pages.\n * @returns An array containing the list of sitemaps and an array of unique page URLs extracted from those sitemaps.\n */\nexport async function getSitemapPages(accessToken: string, siteUrl: string) {\n  const sitemaps = await getSitemapsList(accessToken, siteUrl);\n\n  let pages: string[] = [];\n  for (const url of sitemaps) {\n    const Google = new Sitemapper({\n      url,\n    });\n\n    const { sites } = await Google.fetch();\n    pages = [...pages, ...sites];\n  }\n\n  return [sitemaps, [...new Set(pages)]];\n}","export * from \"./auth\";\nexport * from \"./gsc\";\nexport * from \"./sitemap\";\nexport * from \"./types\";\nexport * from \"./utils\";\n","import { readFileSync, existsSync, mkdirSync, writeFileSync } from \"fs\";\nimport path from \"path\";\nimport {\n  batch, checkCustomUrls,\n  checkSiteUrl,\n  convertToFilePath,\n  convertToSiteUrl,\n  getAccessToken,\n  getEmojiForStatus,\n  getPageIndexingStatus,\n  getPublishMetadata,\n  getSitemapPages,\n  requestIndexing,\n  Status\n} from \"./src\";\n\nconst CACHE_TIMEOUT = 1000 * 60 * 60 * 24 * 14; // 14 days\nexport const QUOTA = {\n  rpm: {\n    retries: 3,\n    waitingTime: 60000, // 1 minute\n  },\n};\n\nexport type IndexOptions = {\n  client_email?: string;\n  private_key?: string;\n  path?: string;\n  urls?: string[];\n  quota?: {\n    rpmRetry?: boolean; // read requests per minute: retry after waiting time\n  };\n};\n\n/**\n * Indexes the specified domain or site URL.\n * @param input - The domain or site URL to index.\n * @param options - (Optional) Additional options for indexing.\n */\nexport const index = async (input: string = process.argv[2], options: IndexOptions = {}) => {\n  if (!input) {\n    console.error(\"❌ Please provide a domain or site URL as the first argument.\");\n    console.error(\"\");\n    process.exit(1);\n  }\n\n  if (!options.client_email) {\n    options.client_email = process.env.GSC_CLIENT_EMAIL;\n  }\n  if (!options.private_key) {\n    options.private_key = process.env.GSC_PRIVATE_KEY;\n  }\n  if (!options.path) {\n    options.path = process.env.GSC_PATH;\n  }\n  if (!options.urls) {\n    options.urls = process.env.GSC_URLS ? process.env.GSC_URLS.split(\",\") : undefined;\n  }\n  if (!options.quota) {\n    options.quota = {\n      rpmRetry: process.env.GSC_QUOTA_RPM_RETRY === \"true\",\n    };\n  }\n\n  const accessToken = await getAccessToken(options.client_email, options.private_key, options.path);\n  let siteUrl = convertToSiteUrl(input);\n  console.log(`🔎 Processing site: ${siteUrl}`);\n  const cachePath = path.join(\".cache\", `${convertToFilePath(siteUrl)}.json`);\n\n  if (!accessToken) {\n    console.error(\"❌ Failed to get access token, check your service account credentials.\");\n    console.error(\"\");\n    process.exit(1);\n  }\n\n  siteUrl = await checkSiteUrl(accessToken, siteUrl);\n\n  let pages = options.urls || [];\n  if (pages.length === 0) {\n    console.log(`🔎 Fetching sitemaps and pages...`);\n    const [sitemaps, pagesFromSitemaps] = await getSitemapPages(accessToken, siteUrl);\n\n    if (sitemaps.length === 0) {\n      console.error(\"❌ No sitemaps found, add them to Google Search Console and try again.\");\n      console.error(\"\");\n      process.exit(1);\n    }\n\n    pages = pagesFromSitemaps;\n\n    console.log(`👉 Found ${pages.length} URLs in ${sitemaps.length} sitemap`);\n  } else {\n    pages = checkCustomUrls(siteUrl, pages);\n    console.log(`👉 Found ${pages.length} URLs in the provided list`);\n  }\n\n  const statusPerUrl: Record<string, { status: Status; lastCheckedAt: string }> = existsSync(cachePath)\n    ? JSON.parse(readFileSync(cachePath, \"utf8\"))\n    : {};\n  const pagesPerStatus: Record<Status, string[]> = {\n    [Status.SubmittedAndIndexed]: [],\n    [Status.DuplicateWithoutUserSelectedCanonical]: [],\n    [Status.CrawledCurrentlyNotIndexed]: [],\n    [Status.DiscoveredCurrentlyNotIndexed]: [],\n    [Status.PageWithRedirect]: [],\n    [Status.URLIsUnknownToGoogle]: [],\n    [Status.RateLimited]: [],\n    [Status.Forbidden]: [],\n    [Status.Error]: [],\n  };\n\n  const indexableStatuses = [\n    Status.DiscoveredCurrentlyNotIndexed,\n    Status.CrawledCurrentlyNotIndexed,\n    Status.URLIsUnknownToGoogle,\n    Status.Forbidden,\n    Status.Error,\n    Status.RateLimited,\n  ];\n\n  const shouldRecheck = (status: Status, lastCheckedAt: string) => {\n    const shouldIndexIt = indexableStatuses.includes(status);\n    const isOld = new Date(lastCheckedAt) < new Date(Date.now() - CACHE_TIMEOUT);\n    return shouldIndexIt && isOld;\n  };\n\n  await batch(\n    async (url) => {\n      let result = statusPerUrl[url];\n      if (!result || shouldRecheck(result.status, result.lastCheckedAt)) {\n        const status = await getPageIndexingStatus(accessToken, siteUrl, url);\n        result = { status, lastCheckedAt: new Date().toISOString() };\n        statusPerUrl[url] = result;\n      }\n\n      pagesPerStatus[result.status] = pagesPerStatus[result.status] ? [...pagesPerStatus[result.status], url] : [url];\n    },\n    pages,\n    50,\n    (batchIndex, batchCount) => {\n      console.log(`📦 Batch ${batchIndex + 1} of ${batchCount} complete`);\n    }\n  );\n\n  console.log(``);\n  console.log(`👍 Done, here's the status of all ${pages.length} pages:`);\n  mkdirSync(\".cache\", { recursive: true });\n  writeFileSync(cachePath, JSON.stringify(statusPerUrl, null, 2));\n\n  for (const status of Object.keys(pagesPerStatus)) {\n    const pages = pagesPerStatus[status as Status];\n    if (pages.length === 0) continue;\n    console.log(`• ${getEmojiForStatus(status as Status)} ${status}: ${pages.length} pages`);\n  }\n  console.log(\"\");\n\n  const indexablePages = Object.entries(pagesPerStatus).flatMap(([status, pages]) =>\n    indexableStatuses.includes(status as Status) ? pages : []\n  );\n\n  if (indexablePages.length === 0) {\n    console.log(`✨ There are no pages that can be indexed. Everything is already indexed!`);\n  } else {\n    console.log(`✨ Found ${indexablePages.length} pages that can be indexed.`);\n    indexablePages.forEach((url) => console.log(`• ${url}`));\n  }\n  console.log(``);\n\n  for (const url of indexablePages) {\n    console.log(`📄 Processing url: ${url}`);\n    const status = await getPublishMetadata(accessToken, url, {\n      retriesOnRateLimit: options.quota.rpmRetry ? QUOTA.rpm.retries : 0,\n    });\n    if (status === 404) {\n      await requestIndexing(accessToken, url);\n      console.log(\"🚀 Indexing requested successfully. It may take a few days for Google to process it.\");\n    } else if (status < 400) {\n      console.log(`🕛 Indexing already requested previously. It may take a few days for Google to process it.`);\n    }\n    console.log(``);\n  }\n\n  console.log(`👍 All done!`);\n  console.log(`💖 Brought to you by https://seogets.com - SEO Analytics.`);\n  console.log(``);\n};\n\nexport * from \"./src\";","{\n  \"name\": \"google-indexing-script\",\n  \"description\": \"Script to get your site indexed on Google in less than 48 hours\",\n  \"version\": \"0.4.0\",\n  \"main\": \"./index.ts\",\n  \"type\": \"commonjs\",\n  \"bin\": {\n    \"gsc\": \"bin/gsc\"\n  },\n  \"scripts\": {\n    \"index\": \"ts-node ./src/cli.ts\",\n    \"build\": \"tsup\",\n    \"dev\": \"tsup --watch\",\n    \"link\": \"npm run build && npm i -g .\"\n  },\n  \"keywords\": [\n    \"google\",\n    \"indexing\",\n    \"search-console\",\n    \"sitemap\",\n    \"seo\",\n    \"google-search\",\n    \"cli\",\n    \"typescript\"\n  ],\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"commander\": \"^12.1.0\",\n    \"googleapis\": \"131.0.0\",\n    \"picocolors\": \"^1.0.1\",\n    \"sitemapper\": \"3.2.8\"\n  },\n  \"prettier\": {\n    \"printWidth\": 120\n  },\n  \"devDependencies\": {\n    \"ts-node\": \"^10.9.2\",\n    \"tsup\": \"^8.0.2\",\n    \"typescript\": \"^5.9.2\"\n  }\n}","#!/usr/bin/env node\nconst { index } = require(\".\");\nconst { Command } = require(\"commander\");\nconst packageJson = require(\"./package.json\");\nconst { green } = require(\"picocolors\");\n\nconst program = new Command(packageJson.name);\n\nprogram\n  .alias(\"gsc\")\n  .version(packageJson.version, \"-v, --version\", \"Hiển thị version.\")\n  .description(packageJson.description)\n  .argument(\"[input]\")\n  .usage(`${green(\"[input]\")} [options]`)\n  .helpOption(\"-h, --help\", \"Hiển thị thông tin hướng dẫn.\")\n  .option(\"-c, --client-email <email>\", \"Địa chỉ email của tài khoản dịch vụ Google.\")\n  .option(\"-k, --private-key <key>\", \"Khoá riêng (private key) của tài khoản dịch vụ Google.\")\n  .option(\"-p, --path <path>\", \"Đường dẫn tới file chứa thông tin xác thực của tài khoản dịch vụ Google.\")\n  .option(\"-u, --urls <urls>\", \"Danh sách URL cần index, phân tách bằng dấu phẩy.\")\n  .option(\"--rpm-retry\", \"Thử lại khi vượt quá giới hạn tần suất (rate limit).\")\n  .action((input, options) => {\n    index(input, {\n      client_email: options.clientEmail,\n      private_key: options.privateKey,\n      path: options.path,\n      urls: options.urls ? options.urls.split(\",\") : undefined,\n      quota: {\n        rpmRetry: options.rpmRetry,\n      },\n    });\n  })\n  .parse(process.argv);\n"],"mappings":"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","names":["path","os","fs","Status","path","Sitemapper","QUOTA","import_fs","import_path","path","pages","exports","module","index"]}